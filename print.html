<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>计算机程序的构造和解释</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> 构造过程抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1_1.html"><strong aria-hidden="true">1.1.</strong> 程序设计的基本元素</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1_1_1.html"><strong aria-hidden="true">1.1.1.</strong> 表达式</a></li><li class="chapter-item expanded "><a href="chapter_1_1_2.html"><strong aria-hidden="true">1.1.2.</strong> 命名和环境</a></li><li class="chapter-item expanded "><a href="chapter_1_1_3.html"><strong aria-hidden="true">1.1.3.</strong> 组合式的求值</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">计算机程序的构造和解释</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-1-章-构造过程抽象"><a class="header" href="#第-1-章-构造过程抽象">第 1 章 构造过程抽象</a></h1>
<blockquote>
<p>心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面：</p>
<ol>
<li>将若干简单认识组合为一个复合认识，由此产生出各种复杂的认识。</li>
<li>将两个认识放在一起对照，不管它们如何简单或者复杂，在这样做时并不将它们合而为一。由此得到有关它们的相互关系的认识。</li>
<li>将有关认识与那些在实际中和它们同在的所有其他认识隔离开，这就是抽象，所有具有普遍性的认识都是这样得到的。</li>
</ol>
<p>— 约翰·洛克，《人类理解研究》，1690年</p>
</blockquote>
<p>我们准备学习的是有关 <strong>计算过程</strong> 的知识。计算过程是存在于计算机里的一类抽象事物，在其演化过程中，这些过程会去操作一些被称为 <strong>数据</strong> 的抽象事物。人们创建出一些称为 <strong>程序</strong> 的规则模式，以知道这类过程的进行。从作用上看，就像是我们在通过自己的写作魔力去控制计算机里的精灵似的。</p>
<p>一个计算过程确实很像一种神灵的巫术，它看不见也摸不到，根本就不是由物质组成的。然而它却又是非常真实的，可以完成某些智力性的工作。它可以回答提问，可以通过在银行里支付现金或者在工厂里操纵机器人等等方式影响这个世界。我们用于指挥这种过程的程序就像是巫师的咒语，它们是用一些诡秘而深奥的 <strong>程序设计语言</strong> ，通过符号表达式的形式精心编排而成，它们描述了我们希望相应的计算过程去完成的工作。</p>
<p>在正常工作的计算机里，一个计算过程将精密而准确地执行相应的程序。这样，初学程序设计的人们就像巫师的徒弟们那样，必须学习如何去理解和预期他们所发出的咒语的效果。程序里即使有一点小错误（常常被称为 <strong>程序错误（bug）</strong> 或者 <strong>故障（glitch）</strong> ），也可能产生复杂而无法预料的后果。</p>
<p>幸运的是，学习程序的危险性远远小于学习巫术，因为我们要去控制的神灵以一种很安全的方式被约束着。而真实的程序设计则需要极度细心，需要经验和智慧。例如，在一个计算机辅助设计系统里的一点小毛病，就可能导致一架飞机或者一座水坝的灾难性损毁，或者一个工业机器人的自我破坏。</p>
<p>软件工程大师们能组织好自己的程序，使自己能合理地确信这些程序所产生的计算过程将能完成预期的工作。他们可以事先看到自己系统的行为方式，知道如何去构造这些程序，使其中出现的意外问题不会导致灾难性的后果。而且，在发生了这种问题时，他们也能 <strong>排除</strong> 程序中的错误，设计良好的计算系统就像设计良好的汽车或者核反应堆一样，具有某种模块化的设计，其中的各个部分都可以独立地构造、替换、排除错误。</p>
<p><strong>用 Lisp 编程</strong></p>
<p>为了描述这类计算过程，我们需要有一种适用的语言。我们将为此使用程序设计语言 Lisp 。正如人们每天用自然语言（如英语、法语或日语等）表述自己的想法，用数学形式的记法描述定量的现象一样，我们将要用 Lisp 表述过程性的思想。Lisp 是 20 世纪 50 年代后期发明的一种记法形式，是为了能对某种特定形式的逻辑表达式（称为 <strong>递归方程</strong> ）的使用做推理。递归方程可以作为计算的模型。这一语言是由 John McCarthy 设计的，基于他的论文《符号表达式的递归函数及其机械计算》。</p>
<p>虽然在开始时， McCarthy 是想以 Lisp 作为一种数学记述形式，但它确实是一种实用的程序设计语言。一个 Lisp <strong>解释器</strong> 就像是一台机器，它能实现用 Lisp 语言描述的计算过程。第一个 Lisp 解释器是 McCarthy 在 MIT 电子研究实验室的人工智能组和 MIT 计算中心里他的同事和学生的帮助下实现的<sup class="footnote-reference"><a href="#1">1</a></sup>。 Lisp 的名字来自表处理（LISt Processing），其设计是为了提供符号计算的能力，以便能用于解决一些程序设计问题，例如代数表达式的符号微分和积分。它包含了适用于这类目的的一些新数据对象，称为原子和表，这是它与那一时代的所有其他语言之间最明显的不同之处。</p>
<p>Lisp 并不是一个刻意的设计努力的结果，它以一种试验性的非正式的方式不断演化，以满足用户的需要和实际实现的各种考虑。 Lisp 的这种非官方演化持续了许多年， Lisp 用户社团具有抵制制定这一语言的“官方”定义企图的传统。这种演化方式以及语言初始概念的灵活和优美，使得 Lisp 成为今天还在广泛使用的历史第二悠久的语言（只有 Fortran 比它更老。）这一语言还在不断调整，以便去包容有关程序设计的最新思想。正因为这样，今天的 Lisp 已经形成了一族方言，它们共享着初始语言的大部分特征，也可能有这样或那样的重要差异。用于本书的 Lisp 方言名为 Scheme<sup class="footnote-reference"><a href="#2">2</a></sup> 。</p>
<p>由于 Lisp 的试验性质以及强调符号操作的特点，开始时的这个语言对于数值计算而言是很低效的，至少与 Fortran 比较时是这样。经过这么多年的发展，人们已经开发出了 Lisp 编译器，它们可以将程序翻译为机器代码，这样的代码能相当高效地完成各种数值计算。 Lisp 已经可以非常有效地用于一些特殊的应用领域<sup class="footnote-reference"><a href="#3">3</a></sup>。虽然 Lisp 还没有完全战胜有关它特别低效的诋毁，但它现在已被用于许多性能并不是最重要考虑因素的应用领域。例如， Lisp 已经成为操作系统外壳语言（shell）的一种选择，作为编辑器（Emacs Lisp）和计算机辅助设计系统的扩充语言等等。</p>
<p>既然 Lisp 并不是一种主流语言，我们为什么要用它作为讨论程序设计的基础呢？这是因为，这一语言具有许多独有的特征，这些特征使它成为研究重要程序的设计、构造，以及各种数据结构，并将其关联于支持它们的语言特征的一种极佳媒介。这些特征之中最重要的就是：计算过程的 Lisp 描述（称为 <strong>过程</strong> ）本身又可以作为 Lisp 的数据来表示和操作。这一事实的重要性在于，现存的许多威力强大的程序设计技术，都依赖于填平在“被动的”数据和“主动的”过程之间的传统划分。正如我们将要看到的， Lisp 可以将过程作为数据进行处理的灵活性，使它成为探索这些技术的最方便的现存语言之一。能将过程表示为数据的能力，也使 Lisp 成为编写那些必须将其他程序当作数据去操作的程序的最佳语言，例如支持计算机语言的解释器和编译器。除了这些考虑之外，用 Lisp 编程本身也是极其有趣的。</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Lisp 1 Programmer's Manual 在 1960 年发表， Lisp 1.5 Programmer's Manual (McCarthy 1965) 在 1962 年发表。有关 Lisp 的早期历史见 McCarthy 1978 。</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>在 20 世纪 70 年代，最主要的两个 Lisp 方言是 MIT 的 MAC 项目中开发的 MacLisp （Moon 1978；Pitman 1983），以及在 Bolt Beranek and Newman Inc. 和 Xerox Palo Alto Research Center 开发的 Interlisp （Teitelman 1974），那时主要的 Lisp 程序都是它们写的。Portable Standard Lisp （Hearn 1969；Griss 1981）是另一种 Lisp 方言，其设计就是为能更容易地移植到不同的计算机上。MacLisp 又发展出一些子方言，例如加州大学伯克利分校开发的 Franz Lisp ，还有 ZetaLisp （Moon 1981），它基于 MIT 人工智能实验室设计的一种专用处理器，这一处理器可以非常高效地运行 Lisp。本书所用的 Lisp 方言称为 Scheme （Steele 1975），是 1975 年由 MIT 人工智能实验室的 Guy Lewis Steele Jr. 和 Gerald Jay Sussman 设计的，后来在 MIT 为了教学使用而重新实现。在 1990 年 Scheme 变成了 IEEE 标准（IEEE 1990）。 Common Lisp 方言 （Steele 1982，Steele 1990）是由 Lisp 社团综合了早前各种 Lisp 方言的特征而开发出来的，希望能做成 Lisp 的工业标准。Common Lisp 在 1994 年成为 ANSI 标准（ANSI 1994）。</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>这方面有一个应用是科学计算的重要突破—有关太阳系统运动的整合，它将以前的结果提高了两个数量级，并显示出太阳系统动力学的混沌性。完成这一计算依靠了一种新的整合算法，一个特殊的编译器以及一台专用计算机，所有这些都是在用 Lisp 写的软件工具的帮助下实现的（Abelson et al. 1992；Sussman 和 Wisdom 1992）。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h2 id="11-程序设计的基本元素"><a class="header" href="#11-程序设计的基本元素">1.1 程序设计的基本元素</a></h2>
<p>一个强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，它还应该成为一种框架，使我们能够在其中组织自己有关计算过程的思想。这样，当我们描述一个语言时，就需要将注意力特别放在这一语言所提供的，能够将简单的认识组合起来形成更复杂认识的方法方面。每一种强有力的语言都为此提供了三种机制。</p>
<ul>
<li><strong>基本表达形式</strong> ，用于表示语言所关心的最简单的个体。</li>
<li><strong>组合的方法</strong> ，通过它们可以从较简单的东西出发构造出复合的元素。</li>
<li><strong>抽象的方法</strong> ，通过它们可以为复合对象命名，并将它们当作单元去操作。</li>
</ul>
<p>在程序设计中，我们需要处理两类要素：过程和数据（以后读者将会发现，它们实际上并不是这样严格分离的）。非形式地说，数据是一种我们希望去操作的“东西”，而过程就是有关操作这些数据的规则的描述。这样，任何强有力的程序设计语言都必须能表述基本的数据和基本的过程，还需要提供对过程和数据进行组合和抽象的方法。</p>
<p>本章只处理简单的数值数据，这就使我们可以把注意力集中到过程构造的规则方面<sup class="footnote-reference"><a href="#4">1</a></sup>。在随后几章里我们将会看到，用于构造过程的这些规则同样也可以用于操作各种数据。</p>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">1</sup>
<p>将数值作为“简单数据”看待实际上完全是一种虚张声势。事实上，对于数值的处理是任何程序设计语言里最错综复杂而且也是最迷惑人的事项之一，其中涉及的典型问题包括，某些计算机系统区分了 <strong>整数</strong> （例如 <code>2</code> ）和 <strong>实数</strong> （例如 <code>2.71</code> ）。那么实数 <code>2.00</code> 和整数 <code>2</code> 不同吗？用于整数的算术运算是否与用于实数的运算相同呢？用 <code>6</code> 除以 <code>2</code> 的结果是 <code>3</code> 还是 <code>3.0</code> ？我们可以表示的最大的数是多少？最多能表示的精度包含了多少个十进制位？整数的表示范围与实数一样吗？显然，上述这些问题以及许多其他问题，都会带来有关舍入和截断误差的一系列问题—这就是数值分析的整个科学领域，因为我们在本书中主要关心的是大规模程序的设计，而不是数值技术，因此将忽略对这些问题的讨论。本章中有关数值的实例将没有常规的舍入动作，而如果对非整数使用具有有限的十进制位数精度的算术运算，就会看到这方面的情况。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h3 id="111-表达式"><a class="header" href="#111-表达式">1.1.1 表达式</a></h3>
<p>开始做程序设计，最简单的方式就是去观看一些与 Lisp 方言 Scheme 解释器交互的典型实例。设想你坐在一台计算机的终端前，用键盘输入了一个 <strong>表达式</strong> ，解释器的响应就是将它对这一表达式的 <strong>求值</strong> 结果显示出来。</p>
<p>你可以键入的一种基本表达式就是数（更准确地说，你键入的是由数字组成的表达式，它表示的是以 10 作为基数的数）。如果你给 Lisp 一个数</p>
<pre><code>486
</code></pre>
<p>解释器的响应是打印出</p>
<pre><code>486
</code></pre>
<p>可以用表示基本过程的表达形式（例如 <code>+</code> 或者 <code>*</code> ），将表示数的表达式组合起来，形成复合表达式，以表示求要把有关过程应用于这些数。例如：</p>
<pre><code>(+ 137 349)
486

(- 1000 334)
666

(* 5 99)
495

(/ 10 5)
2

(+ 2.7 10)
12.7
</code></pre>
<p>像上面这样的表达式称为 <strong>组合式</strong> ，其构成方式就是用一对括号括起来一些表达式，形成一个表，用于表示一个过程应用。在表里最左的元素称为 <strong>运算符</strong> ，其他元素都称为 <strong>运算对象</strong> 。要得到这种组合式的值，采用的方式就是将由运算符所刻画的过程应用于有关的 <strong>实际参数</strong> ，而所谓实际参数也就是那些运算对象的值。</p>
<p>将运算符放在所有运算对象左边，这种形式称为 <strong>前缀</strong> 表示。刚开始看到这种表示时会感到有些不习惯，因为它与常规数学表示差别很大。然后前缀表示也有一些有点，其中之一就是它完全适用于可能带有任意个实参的过程，例如在下面实例中的情况：</p>
<pre><code>(+ 21 35 12 7)
75

(* 25 4 12)
1200
</code></pre>
<p>在这里不会出现歧义，因为运算符总是最左边的元素，而整个表达式的范围也由括号界定。</p>
<p>前缀表示的第二个优点是它可以直接扩充，允许出现组合式 <strong>嵌套</strong> 的情况，也就是说，允许组合式的元素本身又是组合式：</p>
<pre><code>(+ (* 3 5) (- 10 6))
19
</code></pre>
<p>原则上讲，对于这种嵌套的深度，以及 Lisp 解释器可以求值的表达式的整体复杂度，都没有任何限制。倒是我们自己有可能被一些并不很复杂的表达式搞糊涂，例如：</p>
<pre><code>(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
</code></pre>
<p>对于这个表达式，解释器可以马上求值出 <code>57</code> 。将上述表达式写成下面的形式有助于阅读：</p>
<pre><code>(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
</code></pre>
<p>这就是遵循一种称为 <strong>美观打印</strong> 的格式规则。按照这种规则，在写一个很长的组合式时，我们令其中的各个运算对象垂直对齐。这样缩格排列的结果能很好地显示出表达式的结构。</p>
<p>即使对于非常复杂的表达式，解释器也总是按同样的基本循环运作：从终端读入一个表达式，对这个表达式求值，而后打印出得到的结果。这种运作模式常常被人们说成是解释器运行在一个 <strong>读入—求值—打印 循环</strong> 之中。请特别注意，在这里完全没有必要显式地去要求解释器打印表达式的值。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="112-命名和环境"><a class="header" href="#112-命名和环境">1.1.2 命名和环境</a></h3>
<p>程序设计语言中一个必不可少的方面，就是它需要提供一种通过名字去使用计算对象的方式。我们将名字标识符称为 <strong>变量</strong> ，它的 <strong>值</strong> 也就是它所对应的那个对象。</p>
<p>在 Lisp 方言 Scheme 里，给事物命名通过 <code>define</code> （定义）的方式完成，输入：</p>
<pre><code>(define size 2)
</code></pre>
<p>会导致解释器将值 <code>2</code> 与名字 <code>size</code> 相关联。一旦名字 <code>size</code> 与 <code>2</code> 关联之后，我们就可以通过这个名字去引用值 <code>2</code> 了：</p>
<pre><code>size
2

(* 5 size)
10
</code></pre>
<p>下面是另外几个使用 <code>define</code> 的例子：</p>
<pre><code>(define pi 3.14159)

(define radius 10)

(* pi (* radius radius))
314.159

(define circumference (* 2 pi radius))

circumference
62.8318
</code></pre>
<p><code>define</code> 是我们所用的语言里最简单的抽象方法，它允许我们用一个简单的名字去引用一个组合运算的结果，例如上面算出的 <code>circumference</code> 。一般而言，计算得到的对象完全可以具有非常复杂的结构，如果每次需要使用它们时，都必须记住并重复地写出它们的细节，那将是极端不方便的事情。实际上，构造一个复杂的程序，也就是为了去一步步地创建出越来越复杂的计算性对象。解释器使这种逐步的程序构造过程变得非常方便，因为我们可以通过一系列交互式动作，逐步创建起所需要的名字—对象关联。这种特征鼓励人们采用递增的方式去开发和调试程序。在很大程度上，这一情况也出于另一个事实，那就是，一个 Lisp 程序通常总是由一大批相对简单的过程组成的。</p>
<p>应该看到，我们可以将值与符号关联，而后又能提取出这些值，这意味着解释器必须维护某种存储能力，以便保持有关的名字—值对偶的轨迹。这种存储被称为 <strong>环境</strong> （更精确地说，是 <strong>全局环境</strong> ，因为我们以后将看到，在一个计算过程中完全可能涉及若干不同环境）。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="113-组合式的求值"><a class="header" href="#113-组合式的求值">1.1.3 组合式的求值</a></h3>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
