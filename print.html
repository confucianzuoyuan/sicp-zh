<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>计算机程序的构造和解释</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> 构造过程抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1_1.html"><strong aria-hidden="true">1.1.</strong> 程序设计的基本元素</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1_1_1.html"><strong aria-hidden="true">1.1.1.</strong> 表达式</a></li><li class="chapter-item expanded "><a href="chapter_1_1_2.html"><strong aria-hidden="true">1.1.2.</strong> 命名和环境</a></li><li class="chapter-item expanded "><a href="chapter_1_1_3.html"><strong aria-hidden="true">1.1.3.</strong> 组合式的求值</a></li><li class="chapter-item expanded "><a href="chapter_1_1_4.html"><strong aria-hidden="true">1.1.4.</strong> 复合过程</a></li><li class="chapter-item expanded "><a href="chapter_1_1_5.html"><strong aria-hidden="true">1.1.5.</strong> 过程应用的代换模型</a></li><li class="chapter-item expanded "><a href="chapter_1_1_6.html"><strong aria-hidden="true">1.1.6.</strong> 条件表达式和谓词</a></li><li class="chapter-item expanded "><a href="chapter_1_1_7.html"><strong aria-hidden="true">1.1.7.</strong> 实例：采用牛顿法求平方根</a></li><li class="chapter-item expanded "><a href="chapter_1_1_8.html"><strong aria-hidden="true">1.1.8.</strong> 过程作为黑箱抽象</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">计算机程序的构造和解释</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第-1-章-构造过程抽象"><a class="header" href="#第-1-章-构造过程抽象">第 1 章 构造过程抽象</a></h1>
<blockquote>
<p>心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面：</p>
<ol>
<li>将若干简单认识组合为一个复合认识，由此产生出各种复杂的认识。</li>
<li>将两个认识放在一起对照，不管它们如何简单或者复杂，在这样做时并不将它们合而为一。由此得到有关它们的相互关系的认识。</li>
<li>将有关认识与那些在实际中和它们同在的所有其他认识隔离开，这就是抽象，所有具有普遍性的认识都是这样得到的。</li>
</ol>
<p>— 约翰·洛克，《人类理解研究》，1690年</p>
</blockquote>
<p>我们准备学习的是有关 <strong>计算过程</strong> 的知识。计算过程是存在于计算机里的一类抽象事物，在其演化过程中，这些过程会去操作一些被称为 <strong>数据</strong> 的抽象事物。人们创建出一些称为 <strong>程序</strong> 的规则模式，以知道这类过程的进行。从作用上看，就像是我们在通过自己的写作魔力去控制计算机里的精灵似的。</p>
<p>一个计算过程确实很像一种神灵的巫术，它看不见也摸不到，根本就不是由物质组成的。然而它却又是非常真实的，可以完成某些智力性的工作。它可以回答提问，可以通过在银行里支付现金或者在工厂里操纵机器人等等方式影响这个世界。我们用于指挥这种过程的程序就像是巫师的咒语，它们是用一些诡秘而深奥的 <strong>程序设计语言</strong> ，通过符号表达式的形式精心编排而成，它们描述了我们希望相应的计算过程去完成的工作。</p>
<p>在正常工作的计算机里，一个计算过程将精密而准确地执行相应的程序。这样，初学程序设计的人们就像巫师的徒弟们那样，必须学习如何去理解和预期他们所发出的咒语的效果。程序里即使有一点小错误（常常被称为 <strong>程序错误（bug）</strong> 或者 <strong>故障（glitch）</strong> ），也可能产生复杂而无法预料的后果。</p>
<p>幸运的是，学习程序的危险性远远小于学习巫术，因为我们要去控制的神灵以一种很安全的方式被约束着。而真实的程序设计则需要极度细心，需要经验和智慧。例如，在一个计算机辅助设计系统里的一点小毛病，就可能导致一架飞机或者一座水坝的灾难性损毁，或者一个工业机器人的自我破坏。</p>
<p>软件工程大师们能组织好自己的程序，使自己能合理地确信这些程序所产生的计算过程将能完成预期的工作。他们可以事先看到自己系统的行为方式，知道如何去构造这些程序，使其中出现的意外问题不会导致灾难性的后果。而且，在发生了这种问题时，他们也能 <strong>排除</strong> 程序中的错误，设计良好的计算系统就像设计良好的汽车或者核反应堆一样，具有某种模块化的设计，其中的各个部分都可以独立地构造、替换、排除错误。</p>
<p><strong>用 Lisp 编程</strong></p>
<p>为了描述这类计算过程，我们需要有一种适用的语言。我们将为此使用程序设计语言 Lisp 。正如人们每天用自然语言（如英语、法语或日语等）表述自己的想法，用数学形式的记法描述定量的现象一样，我们将要用 Lisp 表述过程性的思想。Lisp 是 20 世纪 50 年代后期发明的一种记法形式，是为了能对某种特定形式的逻辑表达式（称为 <strong>递归方程</strong> ）的使用做推理。递归方程可以作为计算的模型。这一语言是由 John McCarthy 设计的，基于他的论文《符号表达式的递归函数及其机械计算》。</p>
<p>虽然在开始时， McCarthy 是想以 Lisp 作为一种数学记述形式，但它确实是一种实用的程序设计语言。一个 Lisp <strong>解释器</strong> 就像是一台机器，它能实现用 Lisp 语言描述的计算过程。第一个 Lisp 解释器是 McCarthy 在 MIT 电子研究实验室的人工智能组和 MIT 计算中心里他的同事和学生的帮助下实现的<sup class="footnote-reference"><a href="#1">1</a></sup>。 Lisp 的名字来自表处理（LISt Processing），其设计是为了提供符号计算的能力，以便能用于解决一些程序设计问题，例如代数表达式的符号微分和积分。它包含了适用于这类目的的一些新数据对象，称为原子和表，这是它与那一时代的所有其他语言之间最明显的不同之处。</p>
<p>Lisp 并不是一个刻意的设计努力的结果，它以一种试验性的非正式的方式不断演化，以满足用户的需要和实际实现的各种考虑。 Lisp 的这种非官方演化持续了许多年， Lisp 用户社团具有抵制制定这一语言的“官方”定义企图的传统。这种演化方式以及语言初始概念的灵活和优美，使得 Lisp 成为今天还在广泛使用的历史第二悠久的语言（只有 Fortran 比它更老。）这一语言还在不断调整，以便去包容有关程序设计的最新思想。正因为这样，今天的 Lisp 已经形成了一族方言，它们共享着初始语言的大部分特征，也可能有这样或那样的重要差异。用于本书的 Lisp 方言名为 Scheme<sup class="footnote-reference"><a href="#2">2</a></sup> 。</p>
<p>由于 Lisp 的试验性质以及强调符号操作的特点，开始时的这个语言对于数值计算而言是很低效的，至少与 Fortran 比较时是这样。经过这么多年的发展，人们已经开发出了 Lisp 编译器，它们可以将程序翻译为机器代码，这样的代码能相当高效地完成各种数值计算。 Lisp 已经可以非常有效地用于一些特殊的应用领域<sup class="footnote-reference"><a href="#3">3</a></sup>。虽然 Lisp 还没有完全战胜有关它特别低效的诋毁，但它现在已被用于许多性能并不是最重要考虑因素的应用领域。例如， Lisp 已经成为操作系统外壳语言（shell）的一种选择，作为编辑器（Emacs Lisp）和计算机辅助设计系统的扩充语言等等。</p>
<p>既然 Lisp 并不是一种主流语言，我们为什么要用它作为讨论程序设计的基础呢？这是因为，这一语言具有许多独有的特征，这些特征使它成为研究重要程序的设计、构造，以及各种数据结构，并将其关联于支持它们的语言特征的一种极佳媒介。这些特征之中最重要的就是：计算过程的 Lisp 描述（称为 <strong>过程</strong> ）本身又可以作为 Lisp 的数据来表示和操作。这一事实的重要性在于，现存的许多威力强大的程序设计技术，都依赖于填平在“被动的”数据和“主动的”过程之间的传统划分。正如我们将要看到的， Lisp 可以将过程作为数据进行处理的灵活性，使它成为探索这些技术的最方便的现存语言之一。能将过程表示为数据的能力，也使 Lisp 成为编写那些必须将其他程序当作数据去操作的程序的最佳语言，例如支持计算机语言的解释器和编译器。除了这些考虑之外，用 Lisp 编程本身也是极其有趣的。</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Lisp 1 Programmer's Manual 在 1960 年发表， Lisp 1.5 Programmer's Manual (McCarthy 1965) 在 1962 年发表。有关 Lisp 的早期历史见 McCarthy 1978 。</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>在 20 世纪 70 年代，最主要的两个 Lisp 方言是 MIT 的 MAC 项目中开发的 MacLisp （Moon 1978；Pitman 1983），以及在 Bolt Beranek and Newman Inc. 和 Xerox Palo Alto Research Center 开发的 Interlisp （Teitelman 1974），那时主要的 Lisp 程序都是它们写的。Portable Standard Lisp （Hearn 1969；Griss 1981）是另一种 Lisp 方言，其设计就是为能更容易地移植到不同的计算机上。MacLisp 又发展出一些子方言，例如加州大学伯克利分校开发的 Franz Lisp ，还有 ZetaLisp （Moon 1981），它基于 MIT 人工智能实验室设计的一种专用处理器，这一处理器可以非常高效地运行 Lisp。本书所用的 Lisp 方言称为 Scheme （Steele 1975），是 1975 年由 MIT 人工智能实验室的 Guy Lewis Steele Jr. 和 Gerald Jay Sussman 设计的，后来在 MIT 为了教学使用而重新实现。在 1990 年 Scheme 变成了 IEEE 标准（IEEE 1990）。 Common Lisp 方言 （Steele 1982，Steele 1990）是由 Lisp 社团综合了早前各种 Lisp 方言的特征而开发出来的，希望能做成 Lisp 的工业标准。Common Lisp 在 1994 年成为 ANSI 标准（ANSI 1994）。</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>这方面有一个应用是科学计算的重要突破—有关太阳系统运动的整合，它将以前的结果提高了两个数量级，并显示出太阳系统动力学的混沌性。完成这一计算依靠了一种新的整合算法，一个特殊的编译器以及一台专用计算机，所有这些都是在用 Lisp 写的软件工具的帮助下实现的（Abelson et al. 1992；Sussman 和 Wisdom 1992）。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h2 id="11-程序设计的基本元素"><a class="header" href="#11-程序设计的基本元素">1.1 程序设计的基本元素</a></h2>
<p>一个强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，它还应该成为一种框架，使我们能够在其中组织自己有关计算过程的思想。这样，当我们描述一个语言时，就需要将注意力特别放在这一语言所提供的，能够将简单的认识组合起来形成更复杂认识的方法方面。每一种强有力的语言都为此提供了三种机制。</p>
<ul>
<li><strong>基本表达形式</strong> ，用于表示语言所关心的最简单的个体。</li>
<li><strong>组合的方法</strong> ，通过它们可以从较简单的东西出发构造出复合的元素。</li>
<li><strong>抽象的方法</strong> ，通过它们可以为复合对象命名，并将它们当作单元去操作。</li>
</ul>
<p>在程序设计中，我们需要处理两类要素：过程和数据（以后读者将会发现，它们实际上并不是这样严格分离的）。非形式地说，数据是一种我们希望去操作的“东西”，而过程就是有关操作这些数据的规则的描述。这样，任何强有力的程序设计语言都必须能表述基本的数据和基本的过程，还需要提供对过程和数据进行组合和抽象的方法。</p>
<p>本章只处理简单的数值数据，这就使我们可以把注意力集中到过程构造的规则方面<sup class="footnote-reference"><a href="#4">1</a></sup>。在随后几章里我们将会看到，用于构造过程的这些规则同样也可以用于操作各种数据。</p>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">1</sup>
<p>将数值作为“简单数据”看待实际上完全是一种虚张声势。事实上，对于数值的处理是任何程序设计语言里最错综复杂而且也是最迷惑人的事项之一，其中涉及的典型问题包括，某些计算机系统区分了 <strong>整数</strong> （例如 <code>2</code> ）和 <strong>实数</strong> （例如 <code>2.71</code> ）。那么实数 <code>2.00</code> 和整数 <code>2</code> 不同吗？用于整数的算术运算是否与用于实数的运算相同呢？用 <code>6</code> 除以 <code>2</code> 的结果是 <code>3</code> 还是 <code>3.0</code> ？我们可以表示的最大的数是多少？最多能表示的精度包含了多少个十进制位？整数的表示范围与实数一样吗？显然，上述这些问题以及许多其他问题，都会带来有关舍入和截断误差的一系列问题—这就是数值分析的整个科学领域，因为我们在本书中主要关心的是大规模程序的设计，而不是数值技术，因此将忽略对这些问题的讨论。本章中有关数值的实例将没有常规的舍入动作，而如果对非整数使用具有有限的十进制位数精度的算术运算，就会看到这方面的情况。</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h3 id="111-表达式"><a class="header" href="#111-表达式">1.1.1 表达式</a></h3>
<p>开始做程序设计，最简单的方式就是去观看一些与 Lisp 方言 Scheme 解释器交互的典型实例。设想你坐在一台计算机的终端前，用键盘输入了一个 <strong>表达式</strong> ，解释器的响应就是将它对这一表达式的 <strong>求值</strong> 结果显示出来。</p>
<p>你可以键入的一种基本表达式就是数（更准确地说，你键入的是由数字组成的表达式，它表示的是以 10 作为基数的数）。如果你给 Lisp 一个数</p>
<pre><code>486
</code></pre>
<p>解释器的响应是打印出</p>
<pre><code>486
</code></pre>
<p>可以用表示基本过程的表达形式（例如 <code>+</code> 或者 <code>*</code> ），将表示数的表达式组合起来，形成复合表达式，以表示求要把有关过程应用于这些数。例如：</p>
<pre><code>(+ 137 349)
486

(- 1000 334)
666

(* 5 99)
495

(/ 10 5)
2

(+ 2.7 10)
12.7
</code></pre>
<p>像上面这样的表达式称为 <strong>组合式</strong> ，其构成方式就是用一对括号括起来一些表达式，形成一个表，用于表示一个过程应用。在表里最左的元素称为 <strong>运算符</strong> ，其他元素都称为 <strong>运算对象</strong> 。要得到这种组合式的值，采用的方式就是将由运算符所刻画的过程应用于有关的 <strong>实际参数</strong> ，而所谓实际参数也就是那些运算对象的值。</p>
<p>将运算符放在所有运算对象左边，这种形式称为 <strong>前缀</strong> 表示。刚开始看到这种表示时会感到有些不习惯，因为它与常规数学表示差别很大。然后前缀表示也有一些有点，其中之一就是它完全适用于可能带有任意个实参的过程，例如在下面实例中的情况：</p>
<pre><code>(+ 21 35 12 7)
75

(* 25 4 12)
1200
</code></pre>
<p>在这里不会出现歧义，因为运算符总是最左边的元素，而整个表达式的范围也由括号界定。</p>
<p>前缀表示的第二个优点是它可以直接扩充，允许出现组合式 <strong>嵌套</strong> 的情况，也就是说，允许组合式的元素本身又是组合式：</p>
<pre><code>(+ (* 3 5) (- 10 6))
19
</code></pre>
<p>原则上讲，对于这种嵌套的深度，以及 Lisp 解释器可以求值的表达式的整体复杂度，都没有任何限制。倒是我们自己有可能被一些并不很复杂的表达式搞糊涂，例如：</p>
<pre><code>(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
</code></pre>
<p>对于这个表达式，解释器可以马上求值出 <code>57</code> 。将上述表达式写成下面的形式有助于阅读：</p>
<pre><code>(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
</code></pre>
<p>这就是遵循一种称为 <strong>美观打印</strong> 的格式规则。按照这种规则，在写一个很长的组合式时，我们令其中的各个运算对象垂直对齐。这样缩格排列的结果能很好地显示出表达式的结构。</p>
<p>即使对于非常复杂的表达式，解释器也总是按同样的基本循环运作：从终端读入一个表达式，对这个表达式求值，而后打印出得到的结果。这种运作模式常常被人们说成是解释器运行在一个 <strong>读入—求值—打印 循环</strong> 之中。请特别注意，在这里完全没有必要显式地去要求解释器打印表达式的值。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="112-命名和环境"><a class="header" href="#112-命名和环境">1.1.2 命名和环境</a></h3>
<p>程序设计语言中一个必不可少的方面，就是它需要提供一种通过名字去使用计算对象的方式。我们将名字标识符称为 <strong>变量</strong> ，它的 <strong>值</strong> 也就是它所对应的那个对象。</p>
<p>在 Lisp 方言 Scheme 里，给事物命名通过 <code>define</code> （定义）的方式完成，输入：</p>
<pre><code>(define size 2)
</code></pre>
<p>会导致解释器将值 <code>2</code> 与名字 <code>size</code> 相关联。一旦名字 <code>size</code> 与 <code>2</code> 关联之后，我们就可以通过这个名字去引用值 <code>2</code> 了：</p>
<pre><code>size
2

(* 5 size)
10
</code></pre>
<p>下面是另外几个使用 <code>define</code> 的例子：</p>
<pre><code>(define pi 3.14159)

(define radius 10)

(* pi (* radius radius))
314.159

(define circumference (* 2 pi radius))

circumference
62.8318
</code></pre>
<p><code>define</code> 是我们所用的语言里最简单的抽象方法，它允许我们用一个简单的名字去引用一个组合运算的结果，例如上面算出的 <code>circumference</code> 。一般而言，计算得到的对象完全可以具有非常复杂的结构，如果每次需要使用它们时，都必须记住并重复地写出它们的细节，那将是极端不方便的事情。实际上，构造一个复杂的程序，也就是为了去一步步地创建出越来越复杂的计算性对象。解释器使这种逐步的程序构造过程变得非常方便，因为我们可以通过一系列交互式动作，逐步创建起所需要的名字—对象关联。这种特征鼓励人们采用递增的方式去开发和调试程序。在很大程度上，这一情况也出于另一个事实，那就是，一个 Lisp 程序通常总是由一大批相对简单的过程组成的。</p>
<p>应该看到，我们可以将值与符号关联，而后又能提取出这些值，这意味着解释器必须维护某种存储能力，以便保持有关的名字—值对偶的轨迹。这种存储被称为 <strong>环境</strong> （更精确地说，是 <strong>全局环境</strong> ，因为我们以后将看到，在一个计算过程中完全可能涉及若干不同环境）。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="113-组合式的求值"><a class="header" href="#113-组合式的求值">1.1.3 组合式的求值</a></h3>
<p>本章的一个目标，就是要把与过程性思维有关的各种问题隔离出来。现在让我们考虑组合式的求值问题。解释器本身就是按照下面过程工作的。</p>
<ul>
<li>要求值一个组合式，做下面的事情：</li>
</ul>
<ol>
<li>求值该组合式的各个子表达式。</li>
<li>将作为最左子表达式（运算符）的值的那个过程应用于相应的实际参数，所谓实际参数也就是其他子表达式（运算对象）的值。</li>
</ol>
<p>即使是一条这样简单的规则，也显示出计算过程里的一些具有普遍性的重要问题。首先，由上面的第一步可以看到，为了实现对一个组合式的求值过程，我们必须先对组合式里的每个元素执行同样的求值过程。因此，在性质上，这一求值过程是递归的，也就是说，它在自己的工作步骤中，包含着调用这个规则本身的需要。</p>
<p>在这里应该特别注意，采用递归的思想可以多么简洁地描述深度嵌套的情况。如果不用递归，我们就需要把这种情况堪称相当复杂的计算过程。例如，对下列表达式求值：</p>
<pre><code>(* (+ 2 (* 4 6))
   (+ 3 5 7))
</code></pre>
<p>需要将求值规则应用于 4 个不同的组合式。如图 1-1 中所示，我们可以采用一棵树的形式，用图形表示这一组合式的求值过程，其中的每个组合式用一个带分支的结点表示，由它发出的分支对应于组合式里的运算符和各个运算对象。终端结点（即那些不再发出分支的结点）表示的是运算符或者数值。以树的观点看这种求值过程，可以设想那些运算对象的值向上穿行，从终端结点开始，而后在越来越高的层次中组合起来。一般而言，我们应该把递归看作一种处理层次性结构的（像树这样的对象）极强有力的技术。事实上，“值向上穿行”形式的求值形式是一类更一般的计算过程的一个例子，这种计算过程称为 <strong>树形积累</strong> 。</p>
<figure>
    <img src="./images/Fig1.1g.std.svg">
    <figcaption style="text-align: center;">图 1-1 树形表示方法，其中显示了每个子表达式的值</figcaption>
</figure>
<p>进一步的观察告诉我们，反复地应用第一个步骤，总可以把我们带到求值中的某一点，在这里遇到的不是组合式而是基本表达式，例如数、内部运算符或者其他名字。处理这些基础情况的方式如下规定：</p>
<ul>
<li>数的值就是它们所表示的数值。</li>
<li>内部运算符的值就是能完成相应操作的机器指令序列。</li>
<li>其他名字的值就是在环境中关联于这一名字的那个对象。</li>
</ul>
<p>我们可以将第二种规定看作是第三种规定的特殊情况，为此秩序将像 <code>+</code> 和 <code>*</code> 一类的运算符也包含在全局环境里，并将相应的指令序列作为与之关联的“值”。对于初学者，应该指出的关键一点是，环境所扮演的角色就是用于确定表达式中各个符号的意义。在如 Lisp 这样的交互式语言里，如果没有关于有关环境的任何信息，那么说例如表达式 <code>(+ x 1)</code> 的值是毫无意义的，因为需要有环境为符号 <code>x</code> 提供意义（甚至需要它为符号 <code>+</code> 提供意义）。正如我们将要在第 3 章看到的，环境具有普遍性的概念，它为求值过程的进行提供了一种上下文，对于我们理解程序的执行起着极其重要的作用。</p>
<p>请注意，上面给出的求值规则并没有处理定义。例如，对 <code>(define x 3)</code> 的求值并不是将 <code>define</code> 应用于它的两个实际参数：其中的一个是符号 <code>x</code> 的值，另一个是 <code>3</code> 。这是因为 <code>define</code> 的作用就是为 <code>x</code> 关联一个值（也就是说， <code>(define x 3)</code> 并不是一个组合式）。</p>
<p>一般性求值规则的这种例外称为 <strong>特殊形式</strong> ， <code>define</code> 是至今我们已经看到的唯一的一种特殊形式，下面还将看到另外一些特殊形式。每个特殊形式都有其自身的求值规则，各种不同种类的表达式（每种有着与之相关联的求值规则）组成了程序设计语言的语法形式。与大部分其他程序设计语言相比， Lisp 的语法非常简单。也就是说，对各种表达式的求值规则可以描述为一个简单的通用规则和一组针对不多的特殊形式的专门规则。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="114-复合过程"><a class="header" href="#114-复合过程">1.1.4 复合过程</a></h3>
<p>我们已经看到了 Lisp 里的某些元素，它们必然也会出现在任何一种强有力的程序设计语言里。这些东西包括：</p>
<ul>
<li>数和算术运算是基本的数据和过程。</li>
<li>组合式的嵌套提供了一种组织起多个操作的方法。</li>
<li>定义是一种受限的抽象手段，它为名字关联相应的值。</li>
</ul>
<p>现在我们来学习 <strong>过程定义</strong> ，这是一种威力更加强大的抽象技术，通过它可以为复合操作提供名字，而后就可以将这样的操作作为一个单元使用了。</p>
<p>现在我们要考察如何表述“平方”的想法。我们可能想说“求某个东西的平方，就是用它自身去乘以它自身”。在这个语言里，这件事情应该表述为：</p>
<pre><code>(define (square x) (* x x))
</code></pre>
<p>可以按如下方式理解这一描述：</p>
<pre><code>(define (square  x)       (*     x     x))
 |       |       |         |     |     |
 去      平方    某个东西  乘起  它 和 它自身
</code></pre>
<p>这样我们就有了一个 <strong>复合过程</strong> ，给它取的名字是 <code>square</code> 。这一过程表示的是将一个东西乘以它自身的操作。被乘的东西也给定了一个局部名字 <code>x</code> ，它扮演这与自然语言里代词同样的角色。求值这一定义的结果是创建起一个复合过程，并将它关联于名字 <code>square</code> 。</p>
<p>过程定义的一般形式是：</p>
<pre><code>(define (&lt;name&gt; &lt;formal parameters&gt;) &lt;body&gt;)
</code></pre>
<p>其中 <code>&lt;name&gt;</code> 是一个符号，过程定义将在环境中关联于这个符号。 <code>&lt;formal parameters&gt;</code> （形式参数）是一些名字，它们用在过程体中，用于表示过程应用时与它们对应的各个实际参数。 <code>&lt;body&gt;</code> 是一个表达式，在应用这一过程时，这一表达式中的形式参数将用与之对应的实际参数取代，对这样取代后的表达式里的求值，产生出这个过程应用的值。 <code>&lt;name&gt;</code> 和 <code>&lt;formal parameters&gt;</code> 被放在一对括号里，成为一组，就像实际调用被定义过程时的写法。</p>
<p>定义好 <code>square</code> 之后，我们就可以使用它了：</p>
<pre><code>(square 21)
441

(square (+ 2 5))
49

(square (square 3))
81
</code></pre>
<p>我们还可以用 <code>square</code> 作为基本构件去定义其他过程。例如， \( x^2 + y^2 \) 可以表述为：</p>
<pre><code>(+ (square x) (square y))
</code></pre>
<p>现在我们很容易定义一个过程 <code>sum-of-squares</code> ，给它两个数作为实际参数，让它产生这两个数的平方和：</p>
<pre><code>(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 3 4)
25
</code></pre>
<p>现在我们又可以用 <code>sum-of-squares</code> 作为构件，进一步去构造其他过程：</p>
<pre><code>(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))

(f 5)
136
</code></pre>
<p>复合过程的使用方式与基本过程完全一样。实际上，如果人们只看上面 <code>sum-of-squares</code> 的定义，根本就无法分辨出 <code>square</code> 究竟是（像 <code>+</code> 和 <code>*</code> 那样）直接做在解释器里呢，还是被定义为一个复合过程。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="115-过程应用的代换模型"><a class="header" href="#115-过程应用的代换模型">1.1.5 过程应用的代换模型</a></h3>
<p>为了求值一个组合式（其运算符是一个复合过程的名字），解释器的工作方式将完全按照 1.1.3 节中所描述的那样，采用与以运算符名为基本过程的组合式一样的计算过程，也就是说，解释器将对组合式的各个元素求值，而后将得到的那个过程（也就是该组合式里运算符的值）应用于那些实际参数（即组合式里那些运算对象的值）。</p>
<p>我们可以假定，把基本运算符应用于实参的机制已经在解释器里做好了。对于复合过程，过程应用的计算过程是：</p>
<ul>
<li>将复合过程应用于实际参数，就是在将过程体中的每个形参用相应的实参取代之后，对这一过程体求值。</li>
</ul>
<p>为了说明这种计算过程，让我们看看下面组合式的求值：</p>
<pre><code>(f 5)
</code></pre>
<p>其中的 <code>f</code> 是 1.1.4 节定义的那个过程。我们首先提取出 <code>f</code> 的体：</p>
<pre><code>(sum-of-squares (+ a 1) (* a 2))
</code></pre>
<p>而后用实际参数 <code>5</code> 代换其中的形式参数：</p>
<pre><code>(sum-of-squares (+ 5 1) (* 5 2))
</code></pre>
<p>这样，问题就被归约为对另一个组合式的求值，其中有两个运算对象，有关的运算符是 <code>sum-of-squares</code> 。求值这一组合式牵涉到三个子问题：我们必须对其中的运算符求值，以便得到应该去应用的那个过程，还需要求值两个运算对象，以得到过程的实际参数。这里的 <code>(+ 5 1)</code> 产生出 <code>6</code> ， <code>(* 5 2)</code> 产生出 <code>10</code> ，因此我们就需要将 <code>sum-of-squares</code> 过程用于 <code>6</code> 和 <code>10</code> 。用这两个值代换 <code>sum-of-squares</code> 体中的形式参数 <code>x</code> 和 <code>y</code> ，表达式被归约为：</p>
<pre><code>(+ (square 6) (square 10))
</code></pre>
<p>使用 <code>square</code> 的定义又可以将它归约为：</p>
<pre><code>(+ (* 6 6) (* 10 10))
</code></pre>
<p>通过乘法又能将它进一步归约为：</p>
<pre><code>(+ 36 100)
</code></pre>
<p>最后得到：</p>
<pre><code>136
</code></pre>
<p>上面描述的这种计算过程称为过程应用的 <strong>代换模型</strong> ，在考虑本章至今所定义的过程时，我们可以将它看作确定过程应用的“意义”的一种模型。但这里还需要强调两点：</p>
<ul>
<li>代换的作用只是为了帮助我们领会过程调用中的情况，而不是对解释器实际工作方式的具体描述。通常的解释器都不采用直接操作过程的正文，用值去代换形式参数的方式去完成对过程调用的求值。在实际中，它们一般采用提供形式参数的局部环境的方式，产生“代换”的效果。我们将在第 3 章和第 4 章考察一个解释器的细节实现，在那里更完整地讨论这一问题。</li>
<li>随着本书讨论的进展，我们将给出有关解释器如何工作的一系列模型，一个比一个更精细，并最终在第 5 章给出一个完整的解释器和一个编译器。这里的代换模型只是这些模型中的第一个—作为形式化地考虑这种求值过程的起点。一般来说，在模拟科学研究或者工程中的现象时，我们总是从最简单的不完全的模型开始。随着更细致地检查所考虑的问题，这些简单模型也会变得越来越不合适，从而必须用进一步精化的模型取代。代换模型也不例外。特别地，在第 3 章中，我们将要讨论将过程用于“变化的数据”的问题，那时就会看到代换模型完全不行了，必须用更复杂的过程应用模型来代替它。</li>
</ul>
<p><strong>应用序和正则序</strong></p>
<p>按照 1.1.3 节给出的有关求值的描述，解释器首先对运算符和各个运算对象求值，而后将得到的过程应用于得到的实际参数。然而，这并不是执行求值的唯一可能方式。另一种求值模型是先不求出运算对象的值，直到实际需要它们的值时再去做。采用这种求值方式，我们就应该首先用运算对象表达式去代换形式参数，直至得到一个只包含基本运算符的表达式，然后再去执行求值。如果我们采用这一方式，对下面表达式的求值：</p>
<pre><code>(f 5)
</code></pre>
<p>将按照下面的序列逐步展开：</p>
<pre><code>(sum-of-squares (+ 5 1) (* 5 2))
(+    (square (+ 5 1))       (square (* 5 2))   )
(+    (* (+ 5 1) (+ 5 1))    (* (* 5 2) (* 5 2)))
</code></pre>
<p>而后是下面归约：</p>
<pre><code>(+    (* 6 6)    (* 10 10))
(+       36         100)
         136
</code></pre>
<p>这给出了与前面求值模型同样的结果，但其中的计算过程却是不一样的。特别地，在对下面表达式的归约中，对于 <code>(+ 5 1)</code> 和 <code>(* 5 2)</code> 的求值各做了两次：</p>
<pre><code>(* x x)
</code></pre>
<p>其中的 <code>x</code> 分别被代换为 <code>(+ 5 1)</code> 和 <code>(* 5 2)</code> 。</p>
<p>这种“完全展开而后归约”的求值模型称为 <strong>正则序求值</strong> ，与之对应的是现在解释器里实际使用的“先求值参数而后应用”的方式，它称为 <strong>应用序求值</strong> 。可以证明，对那些可以通过替换去模拟，并能产生出合法值的过程应用（包括本书前两章中的所有过程），正则序和应用序求值将产生出同样的值（参见练习 1.5 中一个“非法”值的例子，其中正则序和应用序将给出不同的结果）。</p>
<p>Lisp 采用应用序求值，部分原因在于这样做能避免对于表达式的重复求值（例如上面的 <code>(+ 5 1)</code> 和 <code>(* 5 2)</code> 的情况），从而可以提高一些效率。更重要的是，在超出了可以采用替换方式模拟的过程范围之后，正则序的处理将变得更复杂得多。而在另一些方面，正则序也可以成为特别有价值的工具，我们将在第 3 章和第 4 章研究它的某些内在性质。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="116-条件表达式和谓词"><a class="header" href="#116-条件表达式和谓词">1.1.6 条件表达式和谓词</a></h3>
<p>至此我们能定义出的过程类的表达能力还非常有限，因为还没办法去做某些检测，而后依据检测的结果去确定做不同的操作。例如，我们还无法定义一个过程，使它能计算出一个数的绝对值。完成此事需要先检查一个数是正的、负的或者零，而后依据遇到的不同情况，按照下面规则采取不同的动作：</p>
<p>\[|x| = \begin{cases}
x &amp; 如果  &amp; x &gt; 0\\
0 &amp; 如果  &amp; x = 0\\
-x &amp; 如果  &amp; x &lt; 0\\
\end{cases}\]</p>
<p>这种结构称为一个 <strong>分情况分析</strong> ，在 Lisp 里有着一种针对这类分情况分析的特殊形式，称为 <code>cond</code> （表示“条件”）。在使用形式如下：</p>
<pre><code>(define (abs x)
  (cond ((&gt; x 0) x)
        ((= x 0) 0)
        ((&lt; x 0) (- x))))
</code></pre>
<p>条件表达式的一般性形式为：</p>
<blockquote>
<p>(cond (&lt;\(p_1\)&gt; &lt;\(e_1\)&gt;)<br />
      (&lt;\(p_2\)&gt; &lt;\(e_2\)&gt;)<br />
      ...<br />
      (&lt;\(p_n\)&gt; &lt;\(e_n\)&gt;))</p>
</blockquote>
<p>这里首先包含了一个符号 <code>cond</code> ，在它之后跟着一些称为 <strong>子句</strong> 的用括号括起来的表达式对偶（&lt;\(p\)&gt; &lt;\(e\)&gt;）。在每个对偶中的第一个表达式是一个 <strong>谓词</strong> ，也就是说，这是一个表达式，它的值将被解释为真或者假。</p>
<p>条件表达式的求值方式如下：首先求值谓词 &lt;\(p_1\)&gt; ，如果它的值是 <code>false</code> ，那么就去求值 &lt;\(p_2\)&gt; ，如果 &lt;\(p_2\)&gt; 的值是 <code>false</code> 就去求值 &lt;\(p_3\)&gt; 。这一过程将继续做下去，直到发现了某个谓词的值为真为止。此时解释器就返回相应子句中的 <strong>序列表达式&lt;\(e\)&gt;</strong> 的值，以这个值作为整个条件表达式的值。如果无法找到值为真的 &lt;\(p\)&gt; ， <code>cond</code> 的值就没有定义。</p>
<p>我们用术语 <strong>谓词</strong> 指那些返回真或假的过程，也指那种能求出真或者假的值的表达式。求绝对值的过程 <code>abs</code> 使用了基本谓词 <code>&gt;</code> 、 <code>&lt;</code> 和 <code>=</code> ，这几个谓词都以两个数为参数，分别检查第一个数是否大于、小于或者等于第二个数，并据此分别返回真或者假。</p>
<p>写绝对值函数的另一种方式是：</p>
<pre><code>(define (abs x)
  (cond ((&lt; x 0) (- x))
        (else x)))
</code></pre>
<p>用自然语言来说，就是“如果 <code>x</code> 小于 <code>0</code> 就返回 <code>-x</code> ，否则就返回 <code>x</code> ”。 <code>else</code> 是一个特殊符号，可以用在 <code>cond</code> 的最后一个子句中 &lt;\(p\)&gt; 的位置，这样做时，如果该 <code>cond</code> 前面的所有子句都被跳过，它就会返回最后子句中 &lt;\(e\)&gt; 的值。事实上，所有永远都求出真值的表达式都可以用在 &lt;\(p\)&gt; 的位置上。</p>
<p>下面是又一种写绝对值函数的方式：</p>
<pre><code>(define (abs x)
  (if (&lt; x 0)
      (- x)
      x))
</code></pre>
<p>这里采用的是特殊形式 <code>if</code> ，它是条件表达式的一种受限形式，适用于分情况分析中只有两个情况的需要。 <code>if</code> 表达式的一般形式是：</p>
<blockquote>
<p>(if &lt;<em>predicate</em>&gt; &lt;<em>consequent</em>&gt; &lt;<em>alternative</em>&gt;)</p>
</blockquote>
<p>在求值一个 <code>if</code> 表达式时，解释器从求值其 &lt;<em>predicate</em>&gt; 部分开始，如果 &lt;<em>predicate</em>&gt; 得到真值，解释器就去求值 &lt;<em>consequent</em>&gt; 并返回其值，否则它就去求值 &lt;<em>alternative</em>&gt; 并返回其值。</p>
<p>除了一批基本谓词如 <code>&lt;</code> 、<code>=</code> 和 <code>&gt;</code> 之外，还有一些逻辑复合运算符，利用它们可以构造出各种复合谓词。最常用的三个复合运算符是：</p>
<ul>
<li>(and &lt;\(e_1\)&gt; ... &lt;\(e_2\)&gt;)</li>
</ul>
<p>解释器将从左到右一个个地求值 &lt;\(e\)&gt; ，如果某个 &lt;\(e\)&gt; 求值得到假，这一 <code>and</code> 表达式的值就是假，后面的那些 &lt;\(e\)&gt; 也不再求值了。如果前面所有的 &lt;\(e\)&gt; 都求出真值，这一 <code>and</code> 表达式的值就是最后那个 &lt;\(e\)&gt; 的值。</p>
<ul>
<li>(or &lt;\(e_1\)&gt; ... &lt;\(e_2\)&gt;)</li>
</ul>
<p>解释器将从左到右一个个地求值 &lt;\(e\)&gt; ，如果某个 &lt;\(e\)&gt; 求值得到真， <code>or</code> 表达式就以这个表达式的值作为值，后面的那些 &lt;\(e\)&gt; 也不再求值了。如果所有的 &lt;\(e\)&gt; 都求出假值，这一 <code>or</code> 表达式的值就是假。</p>
<ul>
<li>(not &lt;\(e\)&gt;)</li>
</ul>
<p>如果 &lt;\(e\)&gt; 求出的值是假， <code>not</code> 表达式的值就是真；否则其值为假。</p>
<p>注意， <code>and</code> 和 <code>or</code> 都是特殊形式而不是普通的过程，因为它们的子表达式不一定都求值。 <code>not</code> 则是一个普通的过程。</p>
<p>作为使用这些逻辑复合运算符的例子，数 <code>x</code> 的值位于区间 \(5 &lt; x &lt; 10\) 之中的条件可以写为：</p>
<pre><code>(and (&gt; x 5) (&lt; x 10))
</code></pre>
<p>作为另一个例子，下面定义了一个谓词，它检测某个数是否大于或者等于另一个数：</p>
<pre><code>(define (&gt;= x y)
  (or (&gt; x y) (= x y)))
</code></pre>
<p>或者也可以定义为：</p>
<pre><code>(define (&gt;= x y)
  (not (&lt; x y)))
</code></pre>
<p><strong>练习 1.1</strong> 下面是一系列表达式，对于每个表达式，解释器将输出什么结果？假定这一系列表达式是按照给出的顺序逐个求值的。</p>
<pre><code>10

(+ 5 3 4)

(- 9 1)

(/ 6 2)

(+ (* 2 4) (- 4 6))

(define a 3)

(define b (+ a 1))

(+ a b (* a b))

(= a b)

(if (and (&gt; b a) (&lt; b (* a b)))
    b
    a)

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))

(+ 2 (if (&gt; b a) b a))

(* (cond ((&gt; a b) a)
         ((&lt; a b) b)
         (else -1))
   (+ a 1))
</code></pre>
<p><strong>练习 1.2</strong> 请将下面表达式变换为前缀形式：</p>
<p>\[\frac{5+4+(2-(3-(6+\frac{4}{5})))}{3(6-2)(2-7)}\]</p>
<p><strong>练习 1.3</strong> 请定义一个过程，它以三个数为参数，返回其中较大的两个数之和。</p>
<p><strong>练习 1.4</strong> 请仔细考察上面给出的允许运算符为复合表达式的组合式的求值模型，根据对这一模型的认识描述下面过程的行为：</p>
<pre><code>(define (a-plus-abs-b a b)
  ((if (&gt; b 0) + -) a b))
</code></pre>
<p><strong>练习 1.5</strong> Ben Bitdiddle 发明了一种检测方法，能够确定解释器究竟采用哪种序求值，是采用应用序，还是采用正则序。他定义了下面两个过程：</p>
<pre><code>(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
</code></pre>
<p>而后他求值下面的表达式：</p>
<pre><code>(test 0 (p))
</code></pre>
<p>如果某个解释器采用的是应用序求值， Ben 会看到什么样的情况？如果解释器采用正则序求值，他又会看到什么情况？请对你的回答做出解释。（无论采用正则序或者应用序，假定特殊形式 <code>if</code> 的求值规则总是一样的。其中的谓词部分先行求值，根据其结果确定随后求值的子表达式部分。）</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="117-实例采用牛顿法求平方根"><a class="header" href="#117-实例采用牛顿法求平方根">1.1.7 实例：采用牛顿法求平方根</a></h3>
<p>上面介绍的过程都很像常规的数学函数，它们描述的是如何根据一个或者几个参数去确定一个值。然而，在数学的函数和计算机的过程之间有一个重要差异，那就是，这一过程还必须是有效可行的。</p>
<p>作为目前情况下的一个实例，现在我们来考虑求平方根的问题。我们可以将平方根函数定义为：</p>
<p>\[\sqrt{x}=那样的y，使得y \geq 0而且y^2=x\]</p>
<p>这就描述出了一个完全正统的数学函数，我们可以利用它去判断某个数是否为另一个数的平方根，或根据上面描述，推导出一些有关平方根的一般性事实。然而，在另一方面，这一定义并没有描述一个计算过程，因为它确实没有告诉我们，在给定了一个数之后，如何实际地找到这个数的平方根。即使将这个定义用类似 Lisp 的形式重写一遍也完全无济于事：</p>
<pre><code>(define (sqrt x)
  (the y (and (&gt;= y 0)
              (= (square y) x))))
</code></pre>
<p>这只不过是重新提出了原来的问题。</p>
<p>函数与过程之间的矛盾，不过是在描述一件事情的特征，与描述如何去做这件事情之间的普遍性差异的一个具体反映。换一种说法，人们有时也将它说成是说明性的知识与行动性的知识之间的差异。在数学里，人们通常关心的是说明性的描述（是什么），而在计算机科学里，人们则通常关心行动性的描述（怎么做）。</p>
<p>计算机如何算出平方根呢？最常用的就是牛顿的逐步逼近方法。这一方法告诉我们，如果对 \(x\) 的平方根的值有了一个猜测 \(y\) ，那么就可以通过执行一个简单操作去得到一个更好的猜测：只需要求出 \(y\) 和 \(\frac{x}{y}\) 的平均值（它更接近实际的平方根值）。例如，可以用这种方式去计算 \(2\) 的平方根，假定初始值是 \(1\) ：</p>
<table><thead><tr><th>猜测</th><th>商</th><th>平均值</th></tr></thead><tbody>
<tr><td>\(1\)</td><td>\(\frac{2}{1}=2\)</td><td>\(\frac{2+1}{2}=1.5\)</td></tr>
<tr><td>\(1.5\)</td><td>\(\frac{2}{1.5}=1.3333\)</td><td>\(\frac{1.3333+1.5}{2}=1.4167\)</td></tr>
<tr><td>\(1.4167\)</td><td>\(\frac{2}{1.4167}=1.4118\)</td><td>\(\frac{1.4167+1.4118}{2}=1.4142\)</td></tr>
<tr><td>1.4142</td><td>...</td><td>...</td></tr>
</tbody></table>
<p>继续这一计算过程，我们就能得到对 \(2\) 的平方根的越来越好的近似值。</p>
<p>现在，让我们设法用过程的语言来描述这一计算过程。开始时，我们有了被开方数的值（现在需要做的就是算出它的平方根）和一个猜测值。如果猜测值已经足够好了，有关工作也就完成了。如若不然，那么就需要重复上述计算过程去改进猜测值。我们可以将这一基本策略写成下面的过程：</p>
<pre><code>(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
</code></pre>
<p>改进猜测的方式就是求出它与被开方数除以上一个猜测的平均值：</p>
<pre><code>(define (improve guess x)
  (average guess (/ x guess)))
</code></pre>
<p>其中</p>
<pre><code>(define (average x y)
  (/ (+ x y) 2))
</code></pre>
<p>我们还必须说明什么叫做“足够好”。下面的做法只是为了说明问题，它确实不是一个很好的检测方法（参见练习 1.7 ）。这里的想法是，不断改进答案直至它足够接近平方根，使得其平方与被开放数之差小于某个事先确定的误差值（这里用的是 \(0.001\)）：</p>
<pre><code>(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
</code></pre>
<p>最后还需要一种方式来启动整个工作。例如，我们总用 1 作为对任何数的初始猜测值：</p>
<pre><code>(define (sqrt x)
  (sqrt-iter 1.0 x))
</code></pre>
<p>如果把这些定义都送给解释器，我们就可以使用 <code>sqrt</code> 了，就像可以使用其他过程一样：</p>
<pre><code>(sqrt 9)
3.00009155413138

(sqrt (+ 100 37))
11.704699917758145

(sqrt (+ (sqrt 2) (sqrt 3)))
1.7739279023207892

(square (sqrt 1000))
1000.000369924366
</code></pre>
<p>这个 <code>sqrt</code> 程序也说明，在用于写纯粹的数值计算程序时，至今已介绍的简单程序设计语言已经足以写出可以在其他语言（例如 C 或者 Pascal）中写出的任何东西了。这看起来很让人吃惊，因为这一语言中甚至还没有包括任何迭代结构（循环），它们用于指挥计算机去一遍遍地做某些事情。而在另一方面， <code>sqrt-iter</code> 展示了如何不用特殊的迭代结构来实现迭代，其中只需要使用常规的过程调用能力。</p>
<p><strong>练习 1.6</strong> Alyssa P. Hacker 看不出为什么需要将 <code>if</code> 提供为一种特殊形式，她问：“为什么我不能直接通过 <code>cond</code> 将它定义为一个常规过程呢？” Alyssa 的朋友 Eva Lu Ator 断言确实可以这样做，并定义了 <code>if</code> 的一个新版本：</p>
<pre><code>(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
</code></pre>
<p>Eva 给 Alyssa 演示她的程序：</p>
<pre><code>(new-if (= 2 3) 0 5)
5

(new-if (= 1 1) 0 5)
0
</code></pre>
<p>她很高兴地用自己的 <code>new-if</code> 重写了平方根的程序：</p>
<pre><code>(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x)
                     x)))
</code></pre>
<p>当 Alyssa 试着用这个过程去计算平方根时会发生什么事情呢？请给出解释。</p>
<p><strong>练习 1.7</strong> 对于确定很小的数的平方根而言，在计算平方根中使用的检测 <code>good-enough?</code> 是很不好的。还有，在现实的计算机里，算术运算总是以一定的有限精度进行的。这也会使我们的检测不适合非常大的数的计算。请解释上述论断，用例子说明对很小和很大的数，这种检测都可能失败，实现 <code>good-enough?</code> 的另一种策略是监视猜测值在从一次迭代到下一次的变化情况。当改变值相对与猜测值的比率很小时就结束。请设计一个采用这种终止测试方式的平方根过程。对于很大和很小的数，这一方式都能工作吗？</p>
<p><strong>练习 1.8</strong> 求立方根的牛顿法基于如下事实，如果 \(y\) 是 \(x\) 的立方根的一个近似值，那么下式将给出一个更好的近似值：</p>
<p>\[\frac{\frac{x}{y^2} + 2y}{3}\]</p>
<p>请利用这一公式实现一个类似平方根过程的求立方根的过程。（在 1.3.4 节里，我们将看到如何实现一般性的牛顿法，作为这些求平方根和立方根过程的抽象。）</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="118-过程作为黑箱抽象"><a class="header" href="#118-过程作为黑箱抽象">1.1.8 过程作为黑箱抽象</a></h3>
<p><code>sqrt</code> 是我们用一组手工定义的过程来实现一个计算过程的第一个例子。请注意，在这里 <code>sqrt-iter</code> 的定义是 <strong>递归</strong> 的，也就是说，这一过程的定义基于它自身。能够基于一个过程自身来定义它的想法很可能会令人感到不安，人们可能觉得它不够清晰，这种“循环”定义怎么能有意义呢？是不是完全刻画了一个能够由计算机实现的计算过程呢？在 1.2 节里，我们将更细致地讨论这一问题，现在首先来看看 <code>sqrt</code> 实例所显示出的其他一些要点。</p>
<p>可以看到，对于平方根的计算问题可以自然地分解为若干子问题：怎样说一个猜测是足够好了，怎样去改进一个猜测，等等。这些工作中的每一个都通过一个独立的过程完成，整个 <code>sqrt</code> 程序可以看作一族过程（如图 1-2 所示），它们直接反应了从原问题到子问题的分解。</p>
<figure>
    <img src="./images/Fig1.2.std.svg">
    <figcaption style="text-align: center;">图 1-2 sqrt 程序的过程分解</figcaption>
</figure>
<p>这一分解的重要性，并不仅仅在于它将一个问题分解成了几个部分。当然，我们总可以拿来一个大程序，并将它分割成若干部分——最前面 10 行、后面 10 行、再后面 10 行等等。这里最关键的问题是，分解中的每一个过程完成了一件可以清楚标明的工作，这使它们可以被用作定义其他过程的模块。例如，当我们基于 <code>square</code> 定义过程 <code>good-enough?</code> 之时，就是将 <code>square</code> 看作一个“黑箱”。在这样做时，我们根本无须关注这个过程是如何计算出它的结果的，只需要注意它能计算出平方值的事实。关于平方是如何计算的细节被隐去不提了，可以推迟到后来再考虑。情况确实如此，如果只看 <code>good-enough?</code> 过程，与其说 <code>square</code> 是一个过程，不如说它是一个过程的抽象，即所谓的 <strong>过程抽象</strong> 。在这一抽象层次上，任何能计算出平方的过程都可以同样用。</p>
<p>这样，如果我们只考虑返回值，那么下面这两个求平方的过程就是不可区分的。它们中的每一个都取一个数值参数，产生出这个数的平方作为值。</p>
<pre><code>(define (square x) (* x x))

(define (square x)
  (exp (double (log x))))

(define (double x) (+ x x))
</code></pre>
<p>由此可见，一个过程定义应该能隐藏起一些细节。这将使过程的使用者可能不必自己去写这些过程，而是从其他程序员那里作为一个黑箱而接受了它。用户在使用一个过程时，应该不需要去弄清它是如何实现的。</p>
<p><strong>局部名</strong></p>
<p>过程用户不必去关心的实现细节之一，就是在有关的过程里面形式参数的名字，这是由实现者所选用的。也就是说，下面两个过程定义应该是无法区分的：</p>
<pre><code>(define (square x) (* x x))

(define (square y) (* y y))
</code></pre>
<p>这一原则（过程的意义应该不依赖于其作者为形式参数所选用的名字）从表面看起来很明显，但其影响却非常深远。最直接的影响是，过程的形式参数名必须局部于有关的过程体。例如，我们在前面平方根程序中的 <code>good-enough?</code> 定义里使用了 <code>square</code> ：</p>
<pre><code>(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))
</code></pre>
<p><code>good-enough?</code> 作者的意图就是要去确定，函数的第一个参数的平方是否位于第二个参数附近一定的误差范围内。可以看到， <code>good-enough?</code> 的作者用名字 <code>guess</code> 表示其第一个参数，用 <code>x</code> 表示第二个参数，而送给 <code>square</code> 的实际参数就是 <code>guess</code> 。如果 <code>square</code> 的作者也用 <code>x</code> （上面确实如此）表示参数，那么就可以明显看出， <code>good-enough?</code> 里的 <code>x</code> 必须与 <code>square</code> 里的那个 <code>x</code> 不同。在过程 <code>square</code> 运行时，绝不应该影响 <code>good-enough?</code> 里所用的那个 <code>x</code> 的值，因为在 <code>square</code> 完成计算之后， <code>good-enough?</code> 里可能还需要用 <code>x</code> 的值。</p>
<p>如果参数不是它们所在的过程体里局部的东西，那么 <code>square</code> 里的 <code>x</code> 就会与 <code>good-enough?</code> 里的参数 <code>x</code> 相混淆。如果这样， <code>good-enough?</code> 的行为方式就将依赖于我们所用的 <code>square</code> 的不同版本。这样， <code>square</code> 也就不是我们所希望的黑箱了。</p>
<p>过程的形式参数在过程体里扮演着一种非常特殊的角色，在这里，形式参数的具体名字是什么，其实完全没有关系。这样的名字称为 <strong>约束变量</strong> ，因此我们说，一个过程的定义 <strong>约束</strong> 了它的所有形式参数。如果在一个完整的过程定义里将某个约束变量统一换名，这一过程定义的意义将不会有任何改变。如果一个变量不是被约束的，我们就称它为 <strong>自由的</strong> 。一个名字的定义被约束于的那一集表达式称为这个名字的作用域。在一个过程定义里，被声明为这个过程的形式参数的那些约束变量，就以这个过程的体作为它们的作用域。</p>
<p>在上面 <code>good-enough?</code> 的定义中， <code>guess</code> 和 <code>x</code> 是约束变量，而 <code>&lt;</code> 、<code>-</code>、<code>abs</code> 和 <code>square</code> 则是自由的。要想保证 <code>good-enough?</code> 的意义与我们对 <code>guess</code> 和 <code>x</code> 的名字选择无关，只要求它们的名字与 <code>&lt;</code>、<code>-</code>、<code>abs</code> 和 <code>square</code> 都不同就可以了（如果将 <code>guess</code> 重新命名为 <code>abs</code> ，我们就会因为 <strong>捕获</strong> 了变量名 <code>abs</code> 而引进了一个错误，因为这样做就把一个原本自由的名字变成约束的了）。<code>good-enough?</code> 的意义当然与其中的自由变量有关，显然它的意义依赖于（在这一定义之外的）一些事实：要求符号 <code>abs</code> 是一个过程的名字，该过程能求出一个数的绝对值。如果我们将 <code>good-enough?</code> 的定义里的 <code>abs</code> 换成 <code>cos</code>，它计算出的就会是另一个不同函数了。</p>
<p><strong>内部定义和块结构</strong></p>
<p>至今我们才仅仅分离出了一种可用的名字：过程的形式参数是相应过程体里的局部名字。平方根程序还展现出了另一种情况，我们也会希望能控制其中的名字使用。现在这个程序由几个相互分离的过程组成：</p>
<pre><code>(define (sqrt x)
  (sqrt-iter 1.0 x))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))

(define (improve guess x)
  (average guess (/ x guess)))
</code></pre>
<p>问题是，在这个程序里只有一个过程对用户是重要的，那就是，这里所定义的这个 <code>sqrt</code> 确实是 <code>sqrt</code> 。其他的过程（<code>sqrt-iter</code>、<code>good-enough?</code>和<code>improve</code>）则只会干扰他们的思维，因为他们再也不能定义另一个称为 <code>good-enough?</code> 的过程，作为需要与平方根程序一起使用的其他程序的一部分了，因为现在 <code>sqrt</code> 需要它。在许多程序员一起构造大系统的时候，这一问题将会变得非常严重。举例来说，在构造一个大型的数值过程库时，许多数值函数都需要计算出一系列的近似值，因此我们就可能希望有一些名字为 <code>good-enough?</code> 和 <code>improve</code> 的过程作为其中的辅助过程。由于这些情况，我们也希望将这种子过程局部化，将它们隐藏到 <code>sqrt</code> 里面，以使 <code>sqrt</code> 可以与其他采用逐步逼进的过程共存，让它们中的每一个都有自己的 <code>good-enough?</code> 过程。为了使这一方式成为可能，我们要允许一个过程里带有一些内部定义，使它们是局部于这一过程的。为了使这一方式成为可能，我们要允许一个过程里带有一些内部定义，使它们是局部于这一过程的。例如，在解决平方根问题时，我们可以写：</p>
<pre><code>(define (sqrt x)
  (define (good-enough? guess x)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (sqrt-iter 1.0 x))
</code></pre>
<p>这种嵌套的定义称为 <strong>块结构</strong> ，它是最简单的名字包装问题的一种正确解决方式。实际上，在这里还潜藏着一个很好的想法。除了可以将所用的辅助过程定义放到内部，我们还可能简化它们。因为 <code>x</code> 在 <code>sqrt</code> 的定义中是受约束的，过程 <code>good-enough?</code> 、 <code>improve</code> 和 <code>sqrt-iter</code> 也都定义在 <code>sqrt</code> 里面，也就是说，都在 <code>x</code> 的定义域里。这样，显式地将 <code>x</code> 在这些过程之间传来传去也就没有必要了。我们可以让 <code>x</code> 作为内部定义中的自由变量，如下所示。这样，在外围的 <code>sqrt</code> 被调用时， <code>x</code> 由实际参数得到自己的值。这种方式成为 <strong>词法作用域</strong> 。</p>
<pre><code>(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
</code></pre>
<p>下面将广泛使用这种块结构，以帮助我们将大程序分解成一些容易把握的片段。 <strong>块结构</strong> 的思想来自程序设计语言 Algol 60 ，这种结构出现在各种最新的程序设计语言里，是帮助我们组织大程序的结构的一种重要工具。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
