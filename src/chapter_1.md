# 第 1 章 构造过程抽象

> 心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面：
> 1. 将若干简单认识组合为一个复合认识，由此产生出各种复杂的认识。
> 2. 将两个认识放在一起对照，不管它们如何简单或者复杂，在这样做时并不将它们合而为一。由此得到有关它们的相互关系的认识。
> 3. 将有关认识与那些在实际中和它们同在的所有其他认识隔离开，这就是抽象，所有具有普遍性的认识都是这样得到的。
>
> — 约翰·洛克，《人类理解研究》，1690年

我们准备学习的是有关 **计算过程** 的知识。计算过程是存在于计算机里的一类抽象事物，在其演化过程中，这些过程会去操作一些被称为 **数据** 的抽象事物。人们创建出一些称为 **程序** 的规则模式，以知道这类过程的进行。从作用上看，就像是我们在通过自己的写作魔力去控制计算机里的精灵似的。

一个计算过程确实很像一种神灵的巫术，它看不见也摸不到，根本就不是由物质组成的。然而它却又是非常真实的，可以完成某些智力性的工作。它可以回答提问，可以通过在银行里支付现金或者在工厂里操纵机器人等等方式影响这个世界。我们用于指挥这种过程的程序就像是巫师的咒语，它们是用一些诡秘而深奥的 **程序设计语言** ，通过符号表达式的形式精心编排而成，它们描述了我们希望相应的计算过程去完成的工作。

在正常工作的计算机里，一个计算过程将精密而准确地执行相应的程序。这样，初学程序设计的人们就像巫师的徒弟们那样，必须学习如何去理解和预期他们所发出的咒语的效果。程序里即使有一点小错误（常常被称为 **程序错误（bug）** 或者 **故障（glitch）** ），也可能产生复杂而无法预料的后果。

幸运的是，学习程序的危险性远远小于学习巫术，因为我们要去控制的神灵以一种很安全的方式被约束着。而真实的程序设计则需要极度细心，需要经验和智慧。例如，在一个计算机辅助设计系统里的一点小毛病，就可能导致一架飞机或者一座水坝的灾难性损毁，或者一个工业机器人的自我破坏。

软件工程大师们能组织好自己的程序，使自己能合理地确信这些程序所产生的计算过程将能完成预期的工作。他们可以事先看到自己系统的行为方式，知道如何去构造这些程序，使其中出现的意外问题不会导致灾难性的后果。而且，在发生了这种问题时，他们也能 **排除** 程序中的错误，设计良好的计算系统就像设计良好的汽车或者核反应堆一样，具有某种模块化的设计，其中的各个部分都可以独立地构造、替换、排除错误。

**用 Lisp 编程**

为了描述这类计算过程，我们需要有一种适用的语言。我们将为此使用程序设计语言 Lisp 。正如人们每天用自然语言（如英语、法语或日语等）表述自己的想法，用数学形式的记法描述定量的现象一样，我们将要用 Lisp 表述过程性的思想。Lisp 是 20 世纪 50 年代后期发明的一种记法形式，是为了能对某种特定形式的逻辑表达式（称为 **递归方程** ）的使用做推理。递归方程可以作为计算的模型。这一语言是由 John McCarthy 设计的，基于他的论文《符号表达式的递归函数及其机械计算》。

虽然在开始时， McCarthy 是想以 Lisp 作为一种数学记述形式，但它确实是一种实用的程序设计语言。一个 Lisp **解释器** 就像是一台机器，它能实现用 Lisp 语言描述的计算过程。第一个 Lisp 解释器是 McCarthy 在 MIT 电子研究实验室的人工智能组和 MIT 计算中心里他的同事和学生的帮助下实现的[^1]。 Lisp 的名字来自表处理（LISt Processing），其设计是为了提供符号计算的能力，以便能用于解决一些程序设计问题，例如代数表达式的符号微分和积分。它包含了适用于这类目的的一些新数据对象，称为原子和表，这是它与那一时代的所有其他语言之间最明显的不同之处。

Lisp 并不是一个刻意的设计努力的结果，它以一种试验性的非正式的方式不断演化，以满足用户的需要和实际实现的各种考虑。 Lisp 的这种非官方演化持续了许多年， Lisp 用户社团具有抵制制定这一语言的“官方”定义企图的传统。这种演化方式以及语言初始概念的灵活和优美，使得 Lisp 成为今天还在广泛使用的历史第二悠久的语言（只有 Fortran 比它更老。）这一语言还在不断调整，以便去包容有关程序设计的最新思想。正因为这样，今天的 Lisp 已经形成了一族方言，它们共享着初始语言的大部分特征，也可能有这样或那样的重要差异。用于本书的 Lisp 方言名为 Scheme[^2] 。

由于 Lisp 的试验性质以及强调符号操作的特点，开始时的这个语言对于数值计算而言是很低效的，至少与 Fortran 比较时是这样。经过这么多年的发展，人们已经开发出了 Lisp 编译器，它们可以将程序翻译为机器代码，这样的代码能相当高效地完成各种数值计算。 Lisp 已经可以非常有效地用于一些特殊的应用领域[^3]。虽然 Lisp 还没有完全战胜有关它特别低效的诋毁，但它现在已被用于许多性能并不是最重要考虑因素的应用领域。例如， Lisp 已经成为操作系统外壳语言（shell）的一种选择，作为编辑器（Emacs Lisp）和计算机辅助设计系统的扩充语言等等。

既然 Lisp 并不是一种主流语言，我们为什么要用它作为讨论程序设计的基础呢？这是因为，这一语言具有许多独有的特征，这些特征使它成为研究重要程序的设计、构造，以及各种数据结构，并将其关联于支持它们的语言特征的一种极佳媒介。这些特征之中最重要的就是：计算过程的 Lisp 描述（称为 **过程** ）本身又可以作为 Lisp 的数据来表示和操作。这一事实的重要性在于，现存的许多威力强大的程序设计技术，都依赖于填平在“被动的”数据和“主动的”过程之间的传统划分。正如我们将要看到的， Lisp 可以将过程作为数据进行处理的灵活性，使它成为探索这些技术的最方便的现存语言之一。能将过程表示为数据的能力，也使 Lisp 成为编写那些必须将其他程序当作数据去操作的程序的最佳语言，例如支持计算机语言的解释器和编译器。除了这些考虑之外，用 Lisp 编程本身也是极其有趣的。

[^1]: Lisp 1 Programmer's Manual 在 1960 年发表， Lisp 1.5 Programmer's Manual (McCarthy 1965) 在 1962 年发表。有关 Lisp 的早期历史见 McCarthy 1978 。

[^2]: 在 20 世纪 70 年代，最主要的两个 Lisp 方言是 MIT 的 MAC 项目中开发的 MacLisp （Moon 1978；Pitman 1983），以及在 Bolt Beranek and Newman Inc. 和 Xerox Palo Alto Research Center 开发的 Interlisp （Teitelman 1974），那时主要的 Lisp 程序都是它们写的。Portable Standard Lisp （Hearn 1969；Griss 1981）是另一种 Lisp 方言，其设计就是为能更容易地移植到不同的计算机上。MacLisp 又发展出一些子方言，例如加州大学伯克利分校开发的 Franz Lisp ，还有 ZetaLisp （Moon 1981），它基于 MIT 人工智能实验室设计的一种专用处理器，这一处理器可以非常高效地运行 Lisp。本书所用的 Lisp 方言称为 Scheme （Steele 1975），是 1975 年由 MIT 人工智能实验室的 Guy Lewis Steele Jr. 和 Gerald Jay Sussman 设计的，后来在 MIT 为了教学使用而重新实现。在 1990 年 Scheme 变成了 IEEE 标准（IEEE 1990）。 Common Lisp 方言 （Steele 1982，Steele 1990）是由 Lisp 社团综合了早前各种 Lisp 方言的特征而开发出来的，希望能做成 Lisp 的工业标准。Common Lisp 在 1994 年成为 ANSI 标准（ANSI 1994）。

[^3]: 这方面有一个应用是科学计算的重要突破—有关太阳系统运动的整合，它将以前的结果提高了两个数量级，并显示出太阳系统动力学的混沌性。完成这一计算依靠了一种新的整合算法，一个特殊的编译器以及一台专用计算机，所有这些都是在用 Lisp 写的软件工具的帮助下实现的（Abelson et al. 1992；Sussman 和 Wisdom 1992）。