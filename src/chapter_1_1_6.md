### 1.1.6 条件表达式和谓词

至此我们能定义出的过程类的表达能力还非常有限，因为还没办法去做某些检测，而后依据检测的结果去确定做不同的操作。例如，我们还无法定义一个过程，使它能计算出一个数的绝对值。完成此事需要先检查一个数是正的、负的或者零，而后依据遇到的不同情况，按照下面规则采取不同的动作：

\\[|x| = \begin{cases}
 x & 如果  & x > 0\\\\
 0 & 如果  & x = 0\\\\
-x & 如果  & x < 0\\\\
\end{cases}\\]

这种结构称为一个 **分情况分析** ，在 Lisp 里有着一种针对这类分情况分析的特殊形式，称为 `cond` （表示“条件”）。在使用形式如下：

```
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))
```

条件表达式的一般性形式为：

> (cond (<\\(p_1\\)> <\\(e_1\\)>)  
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;(<\\(p_2\\)> <\\(e_2\\)>)  
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;...  
> &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;(<\\(p_n\\)> <\\(e_n\\)>))

这里首先包含了一个符号 `cond` ，在它之后跟着一些称为 **子句** 的用括号括起来的表达式对偶（<\\(p\\)> <\\(e\\)>）。在每个对偶中的第一个表达式是一个 **谓词** ，也就是说，这是一个表达式，它的值将被解释为真或者假。

条件表达式的求值方式如下：首先求值谓词 <\\(p_1\\)> ，如果它的值是 `false` ，那么就去求值 <\\(p_2\\)> ，如果 <\\(p_2\\)> 的值是 `false` 就去求值 <\\(p_3\\)> 。这一过程将继续做下去，直到发现了某个谓词的值为真为止。此时解释器就返回相应子句中的 **序列表达式<\\(e\\)>** 的值，以这个值作为整个条件表达式的值。如果无法找到值为真的 <\\(p\\)> ， `cond` 的值就没有定义。

我们用术语 **谓词** 指那些返回真或假的过程，也指那种能求出真或者假的值的表达式。求绝对值的过程 `abs` 使用了基本谓词 `>` 、 `<` 和 `=` ，这几个谓词都以两个数为参数，分别检查第一个数是否大于、小于或者等于第二个数，并据此分别返回真或者假。

写绝对值函数的另一种方式是：

```
(define (abs x)
  (cond ((< x 0) (- x))
        (else x)))
```

用自然语言来说，就是“如果 `x` 小于 `0` 就返回 `-x` ，否则就返回 `x` ”。 `else` 是一个特殊符号，可以用在 `cond` 的最后一个子句中 <\\(p\\)> 的位置，这样做时，如果该 `cond` 前面的所有子句都被跳过，它就会返回最后子句中 <\\(e\\)> 的值。事实上，所有永远都求出真值的表达式都可以用在 <\\(p\\)> 的位置上。

下面是又一种写绝对值函数的方式：

```
(define (abs x)
  (if (< x 0)
      (- x)
      x))
```

这里采用的是特殊形式 `if` ，它是条件表达式的一种受限形式，适用于分情况分析中只有两个情况的需要。 `if` 表达式的一般形式是：

> (if <*predicate*> <*consequent*> <*alternative*>)

在求值一个 `if` 表达式时，解释器从求值其 <*predicate*> 部分开始，如果 <*predicate*> 得到真值，解释器就去求值 <*consequent*> 并返回其值，否则它就去求值 <*alternative*> 并返回其值。

除了一批基本谓词如 `<` 、`=` 和 `>` 之外，还有一些逻辑复合运算符，利用它们可以构造出各种复合谓词。最常用的三个复合运算符是：

- (and <\\(e_1\\)> ... <\\(e_2\\)>)

解释器将从左到右一个个地求值 <\\(e\\)> ，如果某个 <\\(e\\)> 求值得到假，这一 `and` 表达式的值就是假，后面的那些 <\\(e\\)> 也不再求值了。如果前面所有的 <\\(e\\)> 都求出真值，这一 `and` 表达式的值就是最后那个 <\\(e\\)> 的值。

- (or <\\(e_1\\)> ... <\\(e_2\\)>)

解释器将从左到右一个个地求值 <\\(e\\)> ，如果某个 <\\(e\\)> 求值得到真， `or` 表达式就以这个表达式的值作为值，后面的那些 <\\(e\\)> 也不再求值了。如果所有的 <\\(e\\)> 都求出假值，这一 `or` 表达式的值就是假。

- (not <\\(e\\)>)

如果 <\\(e\\)> 求出的值是假， `not` 表达式的值就是真；否则其值为假。

注意， `and` 和 `or` 都是特殊形式而不是普通的过程，因为它们的子表达式不一定都求值。 `not` 则是一个普通的过程。

作为使用这些逻辑复合运算符的例子，数 `x` 的值位于区间 \\(5 < x < 10\\) 之中的条件可以写为：

```
(and (> x 5) (< x 10))
```

作为另一个例子，下面定义了一个谓词，它检测某个数是否大于或者等于另一个数：

```
(define (>= x y)
  (or (> x y) (= x y)))
```

或者也可以定义为：

```
(define (>= x y)
  (not (< x y)))
```

**练习 1.1** 下面是一系列表达式，对于每个表达式，解释器将输出什么结果？假定这一系列表达式是按照给出的顺序逐个求值的。

```
10

(+ 5 3 4)

(- 9 1)

(/ 6 2)

(+ (* 2 4) (- 4 6))

(define a 3)

(define b (+ a 1))

(+ a b (* a b))

(= a b)

(if (and (> b a) (< b (* a b)))
    b
    a)

(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))

(+ 2 (if (> b a) b a))

(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
```

**练习 1.2** 请将下面表达式变换为前缀形式：

\\[\frac{5+4+(2-(3-(6+\frac{4}{5})))}{3(6-2)(2-7)}\\]

**练习 1.3** 请定义一个过程，它以三个数为参数，返回其中较大的两个数之和。

**练习 1.4** 请仔细考察上面给出的允许运算符为复合表达式的组合式的求值模型，根据对这一模型的认识描述下面过程的行为：

```
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

**练习 1.5** Ben Bitdiddle 发明了一种检测方法，能够确定解释器究竟采用哪种序求值，是采用应用序，还是采用正则序。他定义了下面两个过程：

```
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
```

而后他求值下面的表达式：

```
(test 0 (p))
```

如果某个解释器采用的是应用序求值， Ben 会看到什么样的情况？如果解释器采用正则序求值，他又会看到什么情况？请对你的回答做出解释。（无论采用正则序或者应用序，假定特殊形式 `if` 的求值规则总是一样的。其中的谓词部分先行求值，根据其结果确定随后求值的子表达式部分。）