### 1.1.8 过程作为黑箱抽象

`sqrt` 是我们用一组手工定义的过程来实现一个计算过程的第一个例子。请注意，在这里 `sqrt-iter` 的定义是 **递归** 的，也就是说，这一过程的定义基于它自身。能够基于一个过程自身来定义它的想法很可能会令人感到不安，人们可能觉得它不够清晰，这种“循环”定义怎么能有意义呢？是不是完全刻画了一个能够由计算机实现的计算过程呢？在 1.2 节里，我们将更细致地讨论这一问题，现在首先来看看 `sqrt` 实例所显示出的其他一些要点。

可以看到，对于平方根的计算问题可以自然地分解为若干子问题：怎样说一个猜测是足够好了，怎样去改进一个猜测，等等。这些工作中的每一个都通过一个独立的过程完成，整个 `sqrt` 程序可以看作一族过程（如图 1-2 所示），它们直接反应了从原问题到子问题的分解。

![](./images/Fig1.2.std.svg)

图 1-2 sqrt 程序的过程分解

这一分解的重要性，并不仅仅在于它将一个问题分解成了几个部分。当然，我们总可以拿来一个大程序，并将它分割成若干部分——最前面 10 行、后面 10 行、再后面 10 行等等。这里最关键的问题是，分解中的每一个过程完成了一件可以清楚标明的工作，这使它们可以被用作定义其他过程的模块。例如，当我们基于 `square` 定义过程 `good-enough?` 之时，就是将 `square` 看作一个“黑箱”。在这样做时，我们根本无须关注这个过程是如何计算出它的结果的，只需要注意它能计算出平方值的事实。关于平方是如何计算的细节被隐去不提了，可以推迟到后来再考虑。情况确实如此，如果只看 `good-enough?` 过程，与其说 `square` 是一个过程，不如说它是一个过程的抽象，即所谓的 **过程抽象** 。在这一抽象层次上，任何能计算出平方的过程都可以同样用。

这样，如果我们只考虑返回值，那么下面这两个求平方的过程就是不可区分的。它们中的每一个都取一个数值参数，产生出这个数的平方作为值。

```
(define (square x) (* x x))

(define (square x)
  (exp (double (log x))))

(define (double x) (+ x x))
```

由此可见，一个过程定义应该能隐藏起一些细节。这将使过程的使用者可能不必自己去写这些过程，而是从其他程序员那里作为一个黑箱而接受了它。用户在使用一个过程时，应该不需要去弄清它是如何实现的。

**局部名**

过程用户不必去关心的实现细节之一，就是在有关的过程里面形式参数的名字，这是由实现者所选用的。也就是说，下面两个过程定义应该是无法区分的：

```
(define (square x) (* x x))

(define (square y) (* y y))
```

这一原则（过程的意义应该不依赖于其作者为形式参数所选用的名字）从表面看起来很明显，但其影响却非常深远。最直接的影响是，过程的形式参数名必须局部于有关的过程体。例如，我们在前面平方根程序中的 `good-enough?` 定义里使用了 `square` ：

```
(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
```

`good-enough?` 作者的意图就是要去确定，函数的第一个参数的平方是否位于第二个参数附近一定的误差范围内。可以看到， `good-enough?` 的作者用名字 `guess` 表示其第一个参数，用 `x` 表示第二个参数，而送给 `square` 的实际参数就是 `guess` 。如果 `square` 的作者也用 `x` （上面确实如此）表示参数，那么就可以明显看出， `good-enough?` 里的 `x` 必须与 `square` 里的那个 `x` 不同。在过程 `square` 运行时，绝不应该影响 `good-enough?` 里所用的那个 `x` 的值，因为在 `square` 完成计算之后， `good-enough?` 里可能还需要用 `x` 的值。

如果参数不是它们所在的过程体里局部的东西，那么 `square` 里的 `x` 就会与 `good-enough?` 里的参数 `x` 相混淆。如果这样， `good-enough?` 的行为方式就将依赖于我们所用的 `square` 的不同版本。这样， `square` 也就不是我们所希望的黑箱了。

过程的形式参数在过程体里扮演着一种非常特殊的角色，在这里，形式参数的具体名字是什么，其实完全没有关系。这样的名字称为 **约束变量** ，因此我们说，一个过程的定义 **约束** 了它的所有形式参数。如果在一个完整的过程定义里将某个约束变量统一换名，这一过程定义的意义将不会有任何改变。如果一个变量不是被约束的，我们就称它为 **自由的** 。一个名字的定义被约束于的那一集表达式称为这个名字的作用域。在一个过程定义里，被声明为这个过程的形式参数的那些约束变量，就以这个过程的体作为它们的作用域。

在上面 `good-enough?` 的定义中， `guess` 和 `x` 是约束变量，而 `<` 、`-`、`abs` 和 `square` 则是自由的。要想保证 `good-enough?` 的意义与我们对 `guess` 和 `x` 的名字选择无关，只要求它们的名字与 `<`、`-`、`abs` 和 `square` 都不同就可以了（如果将 `guess` 重新命名为 `abs` ，我们就会因为 **捕获** 了变量名 `abs` 而引进了一个错误，因为这样做就把一个原本自由的名字变成约束的了）。`good-enough?` 的意义当然与其中的自由变量有关，显然它的意义依赖于（在这一定义之外的）一些事实：要求符号 `abs` 是一个过程的名字，该过程能求出一个数的绝对值。如果我们将 `good-enough?` 的定义里的 `abs` 换成 `cos`，它计算出的就会是另一个不同函数了。

**内部定义和块结构**

至今我们才仅仅分离出了一种可用的名字：过程的形式参数是相应过程体里的局部名字。平方根程序还展现出了另一种情况，我们也会希望能控制其中的名字使用。现在这个程序由几个相互分离的过程组成：

```
(define (sqrt x)
  (sqrt-iter 1.0 x))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))

(define (improve guess x)
  (average guess (/ x guess)))
```

问题是，在这个程序里只有一个过程对用户是重要的，那就是，这里所定义的这个 `sqrt` 确实是 `sqrt` 。其他的过程（`sqrt-iter`、`good-enough?`和`improve`）则只会干扰他们的思维，因为他们再也不能定义另一个称为 `good-enough?` 的过程，作为需要与平方根程序一起使用的其他程序的一部分了，因为现在 `sqrt` 需要它。在许多程序员一起构造大系统的时候，这一问题将会变得非常严重。举例来说，在构造一个大型的数值过程库时，许多数值函数都需要计算出一系列的近似值，因此我们就可能希望有一些名字为 `good-enough?` 和 `improve` 的过程作为其中的辅助过程。由于这些情况，我们也希望将这种子过程局部化，将它们隐藏到 `sqrt` 里面，以使 `sqrt` 可以与其他采用逐步逼进的过程共存，让它们中的每一个都有自己的 `good-enough?` 过程。为了使这一方式成为可能，我们要允许一个过程里带有一些内部定义，使它们是局部于这一过程的。为了使这一方式成为可能，我们要允许一个过程里带有一些内部定义，使它们是局部于这一过程的。例如，在解决平方根问题时，我们可以写：

```
(define (sqrt x)
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (sqrt-iter 1.0 x))
```

这种嵌套的定义称为 **块结构** ，它是最简单的名字包装问题的一种正确解决方式。实际上，在这里还潜藏着一个很好的想法。除了可以将所用的辅助过程定义放到内部，我们还可能简化它们。因为 `x` 在 `sqrt` 的定义中是受约束的，过程 `good-enough?` 、 `improve` 和 `sqrt-iter` 也都定义在 `sqrt` 里面，也就是说，都在 `x` 的定义域里。这样，显式地将 `x` 在这些过程之间传来传去也就没有必要了。我们可以让 `x` 作为内部定义中的自由变量，如下所示。这样，在外围的 `sqrt` 被调用时， `x` 由实际参数得到自己的值。这种方式成为 **词法作用域** 。

```
(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
```

下面将广泛使用这种块结构，以帮助我们将大程序分解成一些容易把握的片段。 **块结构** 的思想来自程序设计语言 Algol 60 ，这种结构出现在各种最新的程序设计语言里，是帮助我们组织大程序的结构的一种重要工具。